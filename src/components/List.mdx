import {
  Meta,
  Canvas,
  Story,
  ArgTypes,
  Description,
} from "@storybook/addon-docs/blocks";
import { Example } from "../../.storybook/blocks/Example";
import * as ListStories from "./list.stories";

<hgroup>

<p className="category">Components</p>

# List

The List component enables you to easily initialize the `listAtom()`.

</hgroup>

## Usage

```tsx
import { createList } from "@form-atoms/list-atom";

const { List } = createList(myAtom);

function InitializeList() {
  return <List initialValue={[]} />;
}
```

<blockquote>
  <strong>ðŸ’¡ Note:</strong>
  The `<List>` is **not** a ReactContext provider, so all the list components like `<List.Item>` will work without it.
  This works, because `listAtom` state lives in the JotaiStore. Render the `<List>` only when you want to initialize your list. 
</blockquote>

## Props

| Name         | Type        | Required? | Description                                                    |
| ------------ | ----------- | --------- | -------------------------------------------------------------- |
| children     | `ReactNode` | Yes       | A react nodes                                                  |
| initialValue | `Value[]`   | No        | A value to initialize the `listAtom`                           |
| store        | `AtomStore` | No        | [A Jotai store](https://jotai.org/docs/core/store#createstore) |

## Examples

<Example of={ListStories.Initialized}>

```tsx
import { InputField, fieldAtom } from "form-atoms";
import { listAtom, createList } from "@form-atoms/list-atom";

const envVars = listAtom({
  value: [],
  fields: () => ({
    variable: fieldAtom({ value: "" }),
    value: fieldAtom({ value: "" }),
  }),
});

const { List } = createList(envVars);

const Example = () => (
  <List
    initialValue={[
      { variable: "NPM_TOKEN", value: "<secret>" },
      { variable: "APP_URL", value: "https://jotai.org" },
    ]}
  >
    <List.Item>
      {({ fields }) => (
        <fieldset role="group">
          <InputField atom={fields.variable} component="input" />
          <InputField atom={fields.value} component="input" />
        </fieldset>
      )}
    </List.Item>
  </List>
);
```

</Example>

## Advanced

<Example of={ListStories.ProgrammaticallySetValue} >

```tsx
import { fieldAtom, InputField, useFieldActions } from "form-atoms";
import { listAtom, createList } from "@form-atoms/list-atom";

const environmentVariablesAtom = listAtom({
  name: "environment",
  value: [
    { variable: "GITHUB_TOKEN", value: "<secret>" },
    { variable: "NPM_TOKEN", value: "<secret>" },
  ],
  fields: () => ({
    variable: fieldAtom({ name: "variable", value: "" }),
    value: fieldAtom({ name: "value", value: "" }),
  }),
});

const { List } = createList(environmentVariablesAtom);

const ProgrammaticControls = () => {
  /**
   * listAtom is fieldAtom, so any useField* hooks work:
   */
  const actions = useFieldActions(environmentVariablesAtom);

  return (
    <>
      <button
        type="button"
        className="outline secondary"
        onClick={() =>
          // clear the field - remove all items
          actions.setValue([])
        }
      >
        Clear
      </button>
      <button
        type="button"
        className="outline contrast"
        onClick={() =>
          // set multiple values
          actions.setValue([
            { variable: "NPM_TOKEN", value: "secrettoken" },
            { variable: "NODE_ENV", value: "production" },
          ])
        }
      >
        Set values from .env file
      </button>
    </>
  );
};

const ProgrammaticallySetValueExample = () => {
  return (
    <List>
      <List.Item>
        {({ fields, remove }) => (
          <div
            style={{
              display: "grid",
              gridGap: 16,
              gridTemplateColumns: "auto auto min-content",
            }}
          >
            <div>
              <InputField
                atom={fields.variable}
                render={(props) => (
                  <input {...props} placeholder="Variable Name" />
                )}
              />
            </div>
            <div>
              <InputField
                atom={fields.value}
                render={(props) => (
                  <input {...props} placeholder="Variable Value" />
                )}
              />
            </div>
            <div>
              <button
                type="button"
                className="outline secondary"
                onClick={remove}
              >
                Remove
              </button>
            </div>
          </div>
        )}
      </List.Item>
      <section className="grid">
        <List.Add>
          {({ add }) => (
            <button
              type="button"
              className="outline"
              onClick={() => actions.add()}
            >
              New variable
            </button>
          )}
        </List.Add>
        <ProgrammaticControls />
      </section>
    </List>
  );
};
```

</Example>

<Example of={ListStories.ValidateAscendingValues} hideFormActions={false}>

```tsx
import { fieldAtom, InputField } from "form-atoms";
import { createList, listAtom } from "@form-atoms/list-atom";

const levels = listAtom({
  value: [],
  name: "levels",
  fields: () => ({ level: fieldAtom<number>({ value: 0 }) }),
  validate: ({ value }) => {
    const errors: string[] = [];

    if (1 < value.length) {
      let [current] = value;

      value.forEach((value, index) => {
        if (index === 0) {
          return;
        }

        if (value.level <= current!.level) {
          errors.push(
            `Level at index ${index} must greater than the previous.`,
          );
        }

        current = value;
      });
    }

    return errors;
  },
});

const { List } = createList(levels);

const Example = () => (
  <List initialValue={[10, 30, 20].map((level) => ({ level }))}>
    <List.Item>
      {({ fields, moveUp, moveDown, remove }) => (
        <div
          style={{
            display: "grid",
            gridGap: 16,
            gridTemplateColumns: "auto min-content min-content min-content",
          }}
        >
          <InputField atom={fields.level} component="input" />
          <button type="button" className="outline" onClick={moveUp}>
            Up
          </button>
          <button type="button" className="outline" onClick={moveDown}>
            Down
          </button>
          <button type="button" className="outline secondary" onClick={remove}>
            Remove
          </button>
        </div>
      )}
    </List.Item>
    <FieldErrors atom={levels} />
  </List>
);

const FieldErrors = <T,>({ atom }: { atom: FieldAtom<T> }) => {
  const errors = useFieldErrors(atom);

  return (
    <>
      {errors.map((error, index) => (
        <p key={index} style={{ color: "var(--pico-color-red-550)" }}>
          {error}
        </p>
      ))}
    </>
  );
};
```

</Example>
