import { Meta } from "@storybook/addon-docs/blocks";
import { Example } from "../../.storybook/blocks/Example";
import * as ListStories from "./list.stories";

<hgroup>

<p className="category">Components</p>

# List

The List component enables you to easily initialize the `listAtom()`.

</hgroup>

## Usage

```tsx
import { createList } from "@form-atoms/list-atom";

const { List } = createList(myAtom);

function InitializeList() {
  return <List initialValue={[]} />;
}
```

<blockquote>
  <strong>ðŸ’¡ Note:</strong>
  The `<List>` is **not** a ReactContext provider, so all the list components like `<List.Item>` will work without it.
  This works, because `listAtom` state lives in the JotaiStore. Render the `<List>` only when you want to initialize your list. 
</blockquote>

## Props

| Name         | Type        | Required? | Description                                                    |
| ------------ | ----------- | --------- | -------------------------------------------------------------- |
| children     | `ReactNode` | Yes       | A react nodes                                                  |
| initialValue | `Value[]`   | No        | A value to initialize the `listAtom`                           |
| store        | `AtomStore` | No        | [A Jotai store](https://jotai.org/docs/core/store#createstore) |

## Examples

<Example of={ListStories.Initialized}>

```tsx
import { InputField, fieldAtom } from "form-atoms";
import { listAtom, createList } from "@form-atoms/list-atom";

const envVars = listAtom({
  fields: () => ({
    variable: fieldAtom({ value: "" }),
    value: fieldAtom({ value: "" }),
  }),
});

const { List } = createList(envVars);

const Example = () => (
  <List
    initialValue={[
      { variable: "NPM_TOKEN", value: "<secret>" },
      { variable: "APP_URL", value: "https://jotai.org" },
    ]}
  >
    <List.Item>
      {({ fields }) => (
        <fieldset role="group">
          <InputField atom={fields.variable} component="input" />
          <InputField atom={fields.value} component="input" />
        </fieldset>
      )}
    </List.Item>
  </List>
);
```

</Example>

## Advanced

<Example of={ListStories.ProgrammaticallySetValue} >

```tsx
import { fieldAtom, InputField, useFieldActions } from "form-atoms";
import { listAtom, createList } from "@form-atoms/list-atom";

const environmentVariablesAtom = listAtom({
  name: "environment",
  value: [
    { variable: "GITHUB_TOKEN", value: "<secret>" },
    { variable: "NPM_TOKEN", value: "<secret>" },
  ],
  fields: () => ({
    variable: fieldAtom({ name: "variable", value: "" }),
    value: fieldAtom({ name: "value", value: "" }),
  }),
});

const { List } = createList(environmentVariablesAtom);

const ProgrammaticControls = () => {
  /**
   * listAtom is fieldAtom, so any useField* hooks work:
   */
  const actions = useFieldActions(environmentVariablesAtom);

  return (
    <>
      <button
        type="button"
        className="outline secondary"
        onClick={() =>
          // clear the field - remove all items
          actions.setValue([])
        }
      >
        Clear
      </button>
      <button
        type="button"
        className="outline contrast"
        onClick={() =>
          // set multiple values
          actions.setValue([
            { variable: "NPM_TOKEN", value: "secrettoken" },
            { variable: "NODE_ENV", value: "production" },
          ])
        }
      >
        Set values from .env file
      </button>
    </>
  );
};

const ProgrammaticallySetValueExample = () => {
  return (
    <List>
      <List.Item>
        {({ fields, remove }) => (
          <div
            style={{
              display: "grid",
              gridGap: 16,
              gridTemplateColumns: "auto auto min-content",
            }}
          >
            <div>
              <InputField
                atom={fields.variable}
                render={(props) => (
                  <input {...props} placeholder="Variable Name" />
                )}
              />
            </div>
            <div>
              <InputField
                atom={fields.value}
                render={(props) => (
                  <input {...props} placeholder="Variable Value" />
                )}
              />
            </div>
            <div>
              <button
                type="button"
                className="outline secondary"
                onClick={remove}
              >
                Remove
              </button>
            </div>
          </div>
        )}
      </List.Item>
      <section className="grid">
        <List.Add>
          {({ add }) => (
            <button
              type="button"
              className="outline"
              onClick={() => actions.add()}
            >
              New variable
            </button>
          )}
        </List.Add>
        <ProgrammaticControls />
      </section>
    </List>
  );
};
```

</Example>

<Example of={ListStories.ValidateAscendingValues} hideFormActions={false}>

```tsx
import { fieldAtom, InputField } from "form-atoms";
import { createList, listAtom } from "@form-atoms/list-atom";

const levels = listAtom({
  name: "levels",
  fields: () => ({ level: fieldAtom<number>({ value: 0 }) }),
  validate: ({ value }) => {
    const errors: string[] = [];

    if (1 < value.length) {
      let [current] = value;

      value.forEach((value, index) => {
        if (index === 0) {
          return;
        }

        if (value.level <= current!.level) {
          errors.push(
            `Level at index ${index} must greater than the previous.`,
          );
        }

        current = value;
      });
    }

    return errors;
  },
});

const { List } = createList(levels);

const Example = () => (
  <List initialValue={[10, 30, 20].map((level) => ({ level }))}>
    <List.Item>
      {({ fields, moveUp, moveDown, remove }) => (
        <div
          style={{
            display: "grid",
            gridGap: 16,
            gridTemplateColumns: "auto min-content min-content min-content",
          }}
        >
          <InputField atom={fields.level} component="input" />
          <button type="button" className="outline" onClick={moveUp}>
            Up
          </button>
          <button type="button" className="outline" onClick={moveDown}>
            Down
          </button>
          <button type="button" className="outline secondary" onClick={remove}>
            Remove
          </button>
        </div>
      )}
    </List.Item>
    <FieldErrors atom={levels} />
  </List>
);

const FieldErrors = <T,>({ atom }: { atom: FieldAtom<T> }) => {
  const errors = useFieldErrors(atom);

  return (
    <>
      {errors.map((error, index) => (
        <p key={index} style={{ color: "var(--pico-color-red-550)" }}>
          {error}
        </p>
      ))}
    </>
  );
};
```

</Example>

<Example of={ListStories.WithComputedField} hideFormActions={false}>

```tsx
import { useCallback, useEffect } from "react";
import { useAtomCallback } from "jotai/utils";
import {
  useFieldValue,
  useFieldActions,
  fieldAtom,
  InputField,
} from "form-atoms";
import { createList, listAtom } from "@form-atoms/list-atom";

/**
 * A reference to the primary 2FA item from the list.
 */
const primary2FA = atom<FieldAtom<string> | null>(null);

const phones = listAtom({
  name: "phones",
  validate: ({ value }) => {
    const hasPrimary = value.some((item) => item.isPrimary);

    if (!hasPrimary && value.length > 0) {
      return ["Please select a primary 2FA method."];
    }

    return [];
  },
  fields: () => {
    const phone = fieldAtom<string>({ value: "" });

    return {
      phone,
      isPrimary: fieldAtom<boolean>({
        /**
         * The initial value is false by default.
         * So when there is no primary2FA choosen, all items will have isPrimary=false, to prompt the user to select one.
         */
        value: false,
        preprocess: (value, get) => {
          const primaryPhone = get(primary2FA);

          if (!primaryPhone) {
            // The form is being initialized, so use the initialValue
            return value;
          }

          /**
           * when the primary item is selected, the isPrimary will be computed
           * by comparing the current phone with the primary2FA reference.
           */
          return primaryPhone === phone;
        },
      }),
    };
  },
});

const { List } = createList(twofactor);

const Example = () => (
  <List
    initialValue={[
      { phone: "+420 123 456 789", isPrimary: true },
      { phone: "+421 987 654 321", isPrimary: false },
      { phone: "+421 999 333 777", isPrimary: false },
    ]}
  >
    <List.Item>
      {({ fields, remove }) => (
        <article>
          <fieldset role="group">
            <InputField atom={fields.phone} component="input" type="tel" />
            <RemoveButton remove={remove} />
          </fieldset>
          <PrimaryRadio phone={fields.phone} isPrimary={fields.isPrimary} />
        </article>
      )}
    </List.Item>
    <FieldErrors atom={levels} />
  </List>
);

function PrimaryRadio({
  phone,
  isPrimary,
}: {
  phone: FieldAtom<string>;
  isPrimary: FieldAtom<boolean>;
}) {
  /**
   * The field is computed, and we treat it as read-only.
   */
  const checked = useFieldValue(isPrimary);
  const setPrimary = useSetAtom(primary2FA);
  /**
   * We need to validate the list when the primary item is changed.
   * Otherwise the list might stay in an invalid state.
   */
  const { validate } = useFieldActions(phones);

  return (
    <label>
      <input
        type="radio"
        name="primary2FA"
        checked={checked}
        onChange={() => {
          setPrimary(phone);
          validate();
        }}
      />
      This is my primary 2FA method
    </label>
  );
}

/**
 * When items are removed from the list, we need to clear the primary2FA reference.
 */
function ClearPrimary() {
  const setPrimary = useSetAtom(primary2FA);

  useEffect(() => {
    console.log("Clearing primary 2FA reference");
    setPrimary(null);
  }, [setPrimary]);

  return null;
}
```

</Example>
